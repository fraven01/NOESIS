{% extends 'base.html' %}
{% load recording_extras %}
{% block title %}Anlage 2 Review{% endblock %}
{% block content %}
<h1 class="text-2xl font-semibold mb-4">Anlage 2 Funktionen pr√ºfen</h1>
<form method="post" class="space-y-4">
    {% csrf_token %}
    <div class="filter-controls mb-2">
        <label>
            <input type="checkbox" id="show-relevant-only-filter" class="mr-2">
            Nur als "vorhanden" markierte Funktionen anzeigen
        </label>
        <button type="button" id="verify-all" class="bg-green-600 text-white px-2 py-1 rounded ml-4">Alle Funktionen pr√ºfen ü§ñ</button>
    </div>
    <div class="mb-3">
        <button type="button" id="expand-all-subquestions" class="bg-gray-300 text-black px-2 py-1 rounded">Alle aufklappen</button>
        <button type="button" id="collapse-all-subquestions" class="bg-gray-300 text-black px-2 py-1 rounded">Alle einklappen</button>
    </div>
    <table class="table-auto w-full border">
        <thead>
            <tr>
                <th class="border px-2">Funktion</th>
                <th class="border px-2">Aktion</th>
                {% for label in labels %}
                <th class="border px-2">{{ label }} (Analyse)</th>
                {% endfor %}
                {% for label in labels %}
                <th class="border px-2">{{ label }} (Review)</th>
                {% endfor %}
            </tr>
        </thead>
        <tbody>
        {% for row in rows %}
            <tr class="{% if row.sub %}subquestion-row collapse subquestions-for-{{ row.func_id }}{% endif %}" data-relevant="{{ row.analysis|get_item:'technisch_vorhanden'|yesno:'true,false,unknown' }}" data-parsed-status="{{ row.analysis|get_item:'technisch_vorhanden'|yesno:'True,False,None' }}" data-parsed-notes="{{ row.analysis|raw_item:'technisch_vorhanden'|get_item:'note' }}">
                <td class="border px-2 {% if row.sub %}pl-8{% endif %}">
                    {% if not row.sub %}
                    <button type="button" class="toggle-button mr-2 bg-gray-200 px-1 rounded" data-target=".subquestions-for-{{ row.func_id }}">+</button>
                    {% endif %}
                    {{ row.name }}
                </td>
                <td class="border px-2 text-center">
                    <button type="button" class="verify-btn" {% if row.sub %}data-sub-id="{{ row.sub_id }}" data-parent="{{ row.func_id }}"{% else %}data-function-id="{{ row.func_id }}"{% endif %}>ü§ñ</button>
                </td>
                {% for field in fields %}
                {% with parsed=row.analysis|raw_item:field %}
                <td class="border px-2 text-center">
                    {% if parsed.value == True %}
                        <span class="status-badge status-ja" title="{{ parsed.note|default:'Keine Zusatzinfo' }}">‚úì Vorhanden</span>
                    {% elif parsed.value == False %}
                        <span class="status-badge status-nein">‚úó Nicht vorhanden</span>
                    {% else %}
                        <span class="status-badge status-unbekannt">? Unbekannt</span>
                    {% endif %}
                </td>
                {% endwith %}
                {% endfor %}
                {% for f in row.form_fields %}
                <td class="border px-2 text-center">
                    {{ f.widget }}
                    {% if f.source %}<span class="text-xs text-gray-500">(Quelle: {{ f.source }})</span>{% endif %}
                </td>
                {% endfor %}
            </tr>
        {% endfor %}
        </tbody>
    </table>
    <div class="space-x-2 mt-2">
        <button type="submit" class="bg-blue-600 text-white px-4 py-2 rounded">Speichern</button>
        <button type="button" id="reset-fields" class="bg-gray-300 text-black px-4 py-2 rounded">Reset</button>
        <button type="button" id="btn-reset-all-reviews" class="bg-gray-300 text-black px-4 py-2 rounded">Alle Bewertungen zur√ºcksetzen</button>
    </div>
</form>
<script>
document.getElementById('show-relevant-only-filter').addEventListener('change', function() {
    const rows = document.querySelectorAll('tbody tr');
    rows.forEach(tr => {
        const relevant = tr.dataset.relevant;
        if (this.checked && relevant !== 'true') {
            tr.style.display = 'none';
        } else {
            tr.style.display = '';
        }
    });
});

const initialStates = {};
document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
    initialStates[cb.name] = cb.checked;
});
document.getElementById('reset-fields').addEventListener('click', () => {
    document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        cb.checked = !!initialStates[cb.name];
    });
});

function getCookie(name){const m=document.cookie.match('(^|;)\\s*'+name+'=([^;]*)');return m?decodeURIComponent(m[2]):null;}
const verifyUrl = '{% url "anlage2_feature_verify" anlage.pk %}';

function triggerVerify(button){
    const fd=new FormData();
    if(button.dataset.functionId){fd.append('function',button.dataset.functionId);} 
    if(button.dataset.subId){fd.append('subquestion',button.dataset.subId);} 
    return fetch(verifyUrl,{method:'POST',headers:{'X-CSRFToken':getCookie('csrftoken')},body:fd})
        .then(resp=>{
            if(!resp.ok){alert('Fehler bei der Pr√ºfung');throw new Error('verify');}
            return resp.json();
        })
        .then(data=>{
            console.log(data);
            const row=button.closest('tr');
            if(!row) return data;
            const newStatus=data.technisch_verfuegbar;
            const statusRadios=row.querySelectorAll('input[type="radio"][name*="-status"]');
            statusRadios.forEach(radio=>{
                if(radio.value===String(newStatus)){
                    radio.checked=true;
                }
            });
            return data;
        })
        .catch(()=>null);
}

document.querySelectorAll('.verify-btn').forEach(btn=>{
    btn.addEventListener('click',async ()=>{btn.disabled=true;await triggerVerify(btn);btn.disabled=false;});
});

// Auf- und Zuklappen aller Unterfragen
document.getElementById('expand-all-subquestions').addEventListener('click', () => {
    document.querySelectorAll('.subquestion-row').forEach(row => row.classList.add('show'));
    document.querySelectorAll('.toggle-button').forEach(btn => btn.textContent = '-');
});

document.getElementById('collapse-all-subquestions').addEventListener('click', () => {
    document.querySelectorAll('.subquestion-row').forEach(row => row.classList.remove('show'));
    document.querySelectorAll('.toggle-button').forEach(btn => btn.textContent = '+');
});

// Individuelles Aufklappen einzelner Hauptfunktionen
document.querySelectorAll('.toggle-button').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll(btn.dataset.target).forEach(row => row.classList.toggle('show'));
        const anyOpen = Array.from(document.querySelectorAll(btn.dataset.target)).some(r => r.classList.contains('show'));
        btn.textContent = anyOpen ? '-' : '+';
    });
});

document.getElementById('verify-all').addEventListener('click',async()=>{
    const allBtn=document.getElementById('verify-all');
    allBtn.disabled=true;
    const funcBtns=Array.from(document.querySelectorAll('.verify-btn[data-function-id]'));
    for(const fb of funcBtns){
        const result=await triggerVerify(fb);
        if(result&&result.technisch_vorhanden===true){
            const subs=Array.from(document.querySelectorAll(`.verify-btn[data-parent='${fb.dataset.functionId}']`));
            for(const sb of subs){await triggerVerify(sb);}
        }
    }
    allBtn.disabled=false;
});

// Reset all review fields to parsed values
document.addEventListener('DOMContentLoaded', function() {
    const resetButton = document.getElementById('btn-reset-all-reviews');

    if (resetButton) {
        resetButton.addEventListener('click', function() {
            // 1. Selektiere alle Tabellenzeilen, die Analyse-Daten enthalten.
            const rows = document.querySelectorAll('tbody tr[data-parsed-status]');

            if (rows.length === 0) {
                alert('Keine Analyse-Daten zum Zur√ºcksetzen gefunden.');
                return;
            }

            // 2. Iteriere √ºber jede dieser Zeilen.
            rows.forEach(row => {
                // 3. Lies den urspr√ºnglichen Status und die Notizen aus dem data-Attribut.
                const parsedStatus = row.dataset.parsedStatus;
                const parsedNotes = row.dataset.parsedNotes || "";

                // 4. Finde die Formular-Elemente INNERHALB der aktuellen Zeile.
                const statusRadios = row.querySelectorAll('input[type="radio"][name*="-status"]');
                const notesTextarea = row.querySelector('textarea[name*="-notes"]');

                // 5. Setze die Radio-Buttons zur√ºck.
                if (statusRadios.length > 0) {
                    let aRadioWasChecked = false;
                    statusRadios.forEach(radio => {
                        // Vergleiche den Wert des Buttons ("True", "False", "None", "") mit dem gespeicherten Status.
                        if (radio.value.toLowerCase() === parsedStatus.toLowerCase()) {
                            radio.checked = true;
                            aRadioWasChecked = true;
                        }
                    });
                    // Falls kein Wert passt (z.B. parsedStatus ist leer), keinen Button ausw√§hlen.
                    if (!aRadioWasChecked) {
                       statusRadios.forEach(radio => radio.checked = false);
                    }
                }

                // 6. Setze das Notiz-Feld zur√ºck.
                if (notesTextarea) {
                    notesTextarea.value = parsedNotes;
                }
            });

            // Informiere den Benutzer, dass die Aktion erfolgreich war.
            alert('Alle Bewertungen wurden auf die urspr√ºnglichen Analysewerte zur√ºckgesetzt.');
        });
    }
});
</script>
{% endblock %}
